# Feature Specification: Root Vagabond Portrait Creator

**Feature Branch**: `001-root-vagabond-portrait`  
**Created**: September 26, 2025  
**Status**: Draft  
**Input**: User description: "Root Vagabond Portrait Creator: a simple web application for generating Root RPG vagabond portraits via a quiz and Gemini AI, as detailed in the full PRD above."

## Clarifications

### Session 2025-09-26

- Q: How should the app handle failures when calling the Gemini API (e.g., rate limits, network errors, invalid responses)? â†’ A: Simple error message with retry button.
- Q: What validation or error handling should be applied to quiz inputs (e.g., empty name, invalid custom text)? â†’ A: Basic required field checks with inline messages.
- Q: Should we add acceptance criteria to define completion for each feature (e.g., quiz submits without errors)? â†’ A: Basic bullets under a new section.
- Q: How should the app handle duplicate character names in the gallery (e.g., allow multiples or prevent)? â†’ A: Allow duplicates.
- Q: What accessibility features should be included (e.g., screen reader support)? â†’ A: Basic ARIA labels and keyboard navigation; prioritize mobile-first UI.

### Session 2025-09-26-override

- Max length for custom fields: 200 characters.
- Edge cases: For empty custom inputs, default to first pre-written option; API error message: "Generation failed. Please try again." with retry; Corrupted gallery JSON: Reset to empty array on load.
- Performance: Quiz completion <2 minutes; Page load <3 seconds.
- Predefined lists: Species: Badger, Bird, Cat, Fox, Mouse, Owl, Rabbit, Raccoon, Squirrel, Wolf, Beaver, Opossum. Playbooks: Adventurer, Arbiter, Harrier, Ranger, Ronin, Scoundrel, Thief, Tinker, Vagrant. (See Requirements for explicit listing.)
- User types/permissions: All users (friends group) can view and save to shared gallery; no auth.
- Data retention: Indefinite storage in JSON file.
- Security: API key in .env; no client exposure.

## Execution Flow (main)

```
1. Parse user description from Input
   â†’ If empty: ERROR "No feature description provided"
2. Extract key concepts from description
   â†’ Identify: actors, actions, data, constraints
3. For each unclear aspect:
   â†’ Mark with [NEEDS CLARIFICATION: specific question]
4. Fill User Scenarios & Testing section
   â†’ If no clear user flow: ERROR "Cannot determine user scenarios"
5. Generate Functional Requirements
   â†’ Each requirement must be testable
   â†’ Mark ambiguous requirements
6. Identify Key Entities (if data involved)
7. Run Review Checklist
   â†’ If any [NEEDS CLARIFICATION]: WARN "Spec has uncertainties"
   â†’ If implementation details found: ERROR "Remove tech details"
8. Return: SUCCESS (spec ready for planning)
```

---

## âš¡ Quick Guidelines

- âœ… Focus on WHAT users need and WHY
- âŒ Avoid HOW to implement (no tech stack, APIs, code structure)
- ðŸ‘¥ Written for business stakeholders, not developers

### Section Requirements

- **Mandatory sections**: Must be completed for every feature
- **Optional sections**: Include only when relevant to the feature
- When a section doesn't apply, remove it entirely (don't leave as "N/A")

### For AI Generation

When creating this spec from a user prompt:

1. **Mark all ambiguities**: Use [NEEDS CLARIFICATION: specific question] for any assumption you'd need to make
2. **Don't guess**: If the prompt doesn't specify something (e.g., "login system" without auth method), mark it
3. **Think like a tester**: Every vague requirement should fail the "testable and unambiguous" checklist item
4. **Common underspecified areas**:
   - User types and permissions
   - Data retention/deletion policies
   - Performance targets and scale
   - Error handling behaviors
   - Integration requirements
   - Security/compliance needs

---

## User Scenarios & Testing _(mandatory)_

### Primary User Story

As a player in the Root RPG, I want to create a unique full-body character portrait through a quick thematic quiz, so that I can enhance my role-playing experience with a visually appealing, game-style image generated by AI.

### Acceptance Scenarios

1. **Given** the user is on the landing page, **When** they select "Create a Vagabond", **Then** they are directed to the 3-step character quiz.
2. **Given** the user completes the quiz with selections or custom inputs, **When** they submit, **Then** the system generates and displays a character portrait based on the provided details.
3. **Given** the user views the results page, **When** they choose "Save", **Then** the character (name, playbook, portrait) is added to the gallery.
4. **Given** the user is on the landing page, **When** they select "View the Gallery", **Then** they see a grid/list of all saved characters with images, names, and playbooks.
5. **Given** the user edits the prompt on the results page, **When** they regenerate, **Then** a new portrait is generated and displayed based on the modified prompt.

### Edge Cases

- What happens when the user selects "Custom" but leaves the text input empty? (Default to first pre-written option.)
- How does the system handle API failures during image generation? (Display "Generation failed. Please try again." with retry option.)
- What if the gallery JSON file is corrupted or missing? (Reset to empty array on load.)

## Requirements _(mandatory)_

### Functional Requirements

- **FR-001**: System MUST display a landing page with rustic woodland theme, offering "Create a Vagabond" and "View the Gallery" options.
- **FR-002**: System MUST guide users through a 3-step quiz: Step 1 for name, species (dropdown), playbook (dropdown); Step 2 for presentation, demeanor, item (radio options with custom text input); Step 3 for scene (radio with custom).
- **FR-003**: System MUST store user quiz choices in a state object (e.g., {name, species, playbook, presentation, demeanor, item, scene}) and pass it to the backend upon submission.
- **FR-004**: System MUST construct a dynamic prompt from the state object and call the Gemini API (with reference image) to generate the portrait.
- **FR-005**: System MUST display a loading indicator during image generation and show the portrait on the results page with "Save", "Edit" (pre-filled prompt textbox for regeneration), and "Try Again" (reset to quiz) options.
- **FR-006**: System MUST save selected characters (name, playbook, portrait URL/image) to a server-side JSON file upon "Save".
- **FR-007**: System MUST render the gallery as a responsive grid/list showing each character's image, name, and playbook; data loaded from the JSON file.
- **FR-008**: System MUST ensure the UI is mobile-friendly with earthy color palette (browns, greens, oranges, creams), serif headings, sans-serif body text, and rustic textures (paper, wood grains).
- **FR-009**: System MUST handle custom inputs by incorporating user text directly into the prompt without validation beyond basic length checks (max 200 characters).
- **FR-010**: System MUST store the Gemini API key securely as an environment variable on the server, with no client-side exposure.

#### Predefined Lists

**Species (for dropdown in Step 1):**

- Badger
- Bird
- Cat
- Fox
- Mouse
- Owl
- Rabbit
- Raccoon
- Squirrel
- Wolf
- Beaver
- Opossum

**Playbooks (for dropdown in Step 1):**

- Adventurer
- Arbiter
- Harrier
- Ranger
- Ronin
- Scoundrel
- Thief
- Tinker
- Vagrant

### Key Entities _(include if feature involves data)_

- **Character**: Represents a generated vagabond; key attributes: name (string), species (string from predefined list), playbook (string from predefined list), presentation (string), demeanor (string), item (string), scene (string), portrait (image URL or base64).
- **Gallery**: Collection of saved Characters; stored as JSON array on server, with relationships: each entry links back to its Character attributes for display.

---

## Review & Acceptance Checklist

_GATE: Automated checks run during main() execution_

### Content Quality

- [x] No implementation details (languages, frameworks, APIs)
- [x] Focused on user value and business needs
- [x] Written for non-technical stakeholders
- [x] All mandatory sections completed

### Requirement Completeness

- [x] No [NEEDS CLARIFICATION] markers remain
- [x] Requirements are testable and unambiguous
- [x] Success criteria are measurable
- [x] Scope is clearly bounded
- [x] Dependencies and assumptions identified

---

## Execution Status

_Updated by main() during processing_

- [x] User description parsed
- [x] Key concepts extracted
- [x] Ambiguities marked
- [x] User scenarios defined
- [x] Requirements generated
- [x] Entities identified
- [x] Review checklist passed

---
